# 꼭 필요한 자료구조 기초
- 스택 : First in Last Out 구조
  - stack = [] 처럼, 리스트로 스택 구현
  - 가장 위에 넣고, 가장 위에서 빼야함
    - stack.append(n)
    - stack.pop()

- 큐 : First in First Out 구조
  - queue = deque() 처럼, deque를 사용
     - from collections import deque 를 먼저 해주어야 함
  - 넣은 차례대로 나오게 해야함 (뒤에다가 이어 붙이고, 나올 땐 앞에서부터)
    - queue.append(n)
    - queue.popleft()  # 왼쪽에서 pop 하기
  - deque 객체는 사용을 위해서 list(deque)를 통해 리스트로 자주 바꿈

- 재귀함수
  - 함수 내에서 그 함수를 호출 (예시 : 팩토리얼 구하기)
    - 대신, 너무 많이 재귀가 이루어지면 재귀깊이의 한계로 코드가 작동하지 않음
    - 즉, 코딩테스트에서 너무 깊은 재귀는 시간초과가 발생!
      - 해결을 위해 메모이제이션(Memoization) 기법 등을 활용함
  - "탈출조건" 을 잘 설정해주어야 함 (예시 : 팩토리얼에서는 n = 0이면 f(n) = 1)

# 그래프의 기본 구조
- 그래프는 노드Node(=정점Vertex)과 간선Edge으로 표현됨
- 그래프 표현방식 2가지
  - 인접 행렬 : 2차원 배열로 그래프의 연결 관계를 표현하는 방식
  - 인접 리스트 : 리스트로 그래프의 연결 관계를 표현하는 방식

# DFS - 깊이 우선 탐색 : 스택 => 재귀
- 특정한 경로로 탐색하다가 특정한 상황에서 최대한 깊이 들어가서 노드를 방문한 후, 다시 돌아가 다른 경로로 탐색하는 알고리즘
- 탐색 방법
  - 1 - 탐색 노드를 스택에 삽입하고 방문 처리
  - 2 - 스택의 최상단 노드에 방문하지 않은 인접 노드가 있으면 그 인접 노드를 스택에 넣고 방문 처리. 방문하지 않은 인접 노드가 없으면 스택에서 최상단 노드를 꺼냄
  - 3 - 2번의 과정을 더 이상 수행할 수 없을 때까지 반복함

# BFS - 넓이 우선 탐색 : 큐 => while문
- 인접한 노드를 정해진 순서대로 탐색하는 알고리즘
- 탐색 방법
  - 1 - 탐색 시작 노드를 큐에 삽입하고 방문 처리
  - 2 - 큐에서 노드를 꺼내 해당 노드의 인접 노드 중에서 방문하지 않은 노드를 모두 큐에 삽입하고 방문 처리
  - 3 - 2번의 과정을 더 이상 수행할 수 없을 때까지 반복


# 코딩테스트 주의사항
코딩 테스트에서는 보통 BFS가 DFS보다 조금 더 빠르게 동작한다 정도로 이해하면 됨